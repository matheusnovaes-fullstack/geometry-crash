<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Geometry Crash</title>
  <style>
    :root{
      --bg1:#081421;
      --panel:#0d1b26;
      --accent:#00f0d1;
      --accent-2:#00d0ff;
      --accent-3:#63f5ff;
      --danger:#ff5a5a;
      --gold:#ffd166;
      --card:#0f1720;
      --muted:#99a0a6;
      --glass: rgba(255,255,255,0.06);
      --glass-brd: rgba(255,255,255,0.08);
    }
    html,body{
      height:100%;
      margin:0;
      font-family:Inter, "Segoe UI", Roboto, Arial, sans-serif;
      background: linear-gradient(180deg,var(--bg1), #071018 80%);
      color:#e6f7f2;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .container{
      max-width:720px;
      margin:18px auto;
      padding:18px;
      box-sizing:border-box;
      text-align:center;
    }
    h1{ margin:0 0 12px; font-size:20px; letter-spacing:0.5px;}
    .game-card{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
      border-radius:12px;
      padding:14px;
      box-shadow: 0 6px 30px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      align-items:center;
    }
    canvas{
      background: linear-gradient(180deg,#031219 0%, #071423 100%);
      width:100%;
      max-width:640px;
      height:360px;
      border-radius:12px; /* IMPROVEMENT: radius um pouco maior */
      border:2px solid rgba(0,240,209,0.10); /* IMPROVEMENT: mais vis√≠vel */
      box-shadow:
        0 12px 48px rgba(0,0,0,0.7),
        0 0 24px rgba(0,240,209,0.10),
        inset 0 0 0 1px rgba(255,255,255,0.02);
      outline: none;
    }
    #hud{
      margin-top:10px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
    }
    .scoreBox{
      position:relative;
      background: var(--glass);
      -webkit-backdrop-filter: blur(6px);
      backdrop-filter: blur(6px); /* IMPROVEMENT: glassmorphism */
      padding:8px 12px;
      border-radius:10px;
      font-weight:700;
      color:var(--accent);
      border:1px solid var(--glass-brd);
      box-shadow: 0 4px 18px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.06);
    }
    .record{ color:var(--gold); }
    #jumpBtn{
      display:inline-block;
      margin-left:6px;
      padding:10px 16px;
      border-radius:12px;
      background:linear-gradient(180deg,var(--accent),var(--accent-2));
      border:none;
      color:#012;
      font-weight:800;
      cursor:pointer;
      box-shadow:0 8px 18px rgba(0,208,255,0.18);
      transition: transform .06s ease, box-shadow .12s ease, filter .12s ease;
    }
    #jumpBtn:hover{ filter: brightness(1.05); }
    #jumpBtn:active{ transform: translateY(1px) scale(0.99); }
    #jumpBtn:focus-visible{
      outline: 2px solid var(--accent-3);
      outline-offset: 2px;
    }
    .muted{ color:var(--muted); font-size:13px; }
    .controls{ margin-top:8px; font-size:13px; color:var(--muted); }

    @media(max-width:520px){
      canvas{ height:300px; }
      #jumpBtn{ padding:12px 18px; font-size:16px; }
    }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Jogo Geometry Crash"> <!-- IMPROVEMENT: a11y role -->
    <h1>Geometry Crash ‚Äî Jogue enquanto espera</h1>
    <div class="game-card">
      <canvas id="game" width="640" height="360" role="img" aria-label="Jogo Geometry Crash" tabindex="0"></canvas> <!-- IMPROVEMENT: tabindex para foco/Space -->

      <div id="hud">
        <div class="scoreBox">Pontua√ß√£o: <span id="score">0</span></div>
        <div class="scoreBox record">Recorde: <span id="record">0</span></div>
        <button id="jumpBtn" aria-label="Pular">PULAR</button>
      </div>

      <div class="controls muted">Toque / Clique ou Espa√ßo para pular ‚Äî Recorde salvo localmente</div>
    </div>
  </div>

  <!-- Sons (fontes p√∫blicas do Google Actions) -->
  <audio id="sndJump" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>
  <audio id="sndPoint" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg" preload="auto"></audio>
  <audio id="sndDie" src="https://actions.google.com/sounds/v1/cartoon/concussive_hit_guitar_boing.ogg" preload="auto"></audio>

  <script>
  (function(){
    // Canvas & DPI scaling (IMPROVEMENT: high-DPI crispness)
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    function setupDPI() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      // Logical rendering size used by game world:
      return { W: rect.width, H: rect.height, dpr };
    }

    let { W, H } = setupDPI();
    window.addEventListener('resize', () => {
      const prevScore = score;
      const prevRecord = record;
      ({ W, H } = setupDPI());
      groundY = H - 40;
      // Reposiciona player no ch√£o
      player.y = groundY - player.h;
      score = prevScore;
      record = prevRecord;
    });

    let groundY = H - 40;
    const jumpBtn = document.getElementById('jumpBtn');
    const scoreEl = document.getElementById('score');
    const recordEl = document.getElementById('record');
    const sndJump = document.getElementById('sndJump');
    const sndPoint = document.getElementById('sndPoint');
    const sndDie = document.getElementById('sndDie');

    // Player (tri√¢ngulo)
    let player = {
      x: 80, y: groundY - 24, w: 24, h: 24,
      dy: 0, gravity: 0.9, jumpForce: -12, grounded: true,
      color: '#00f0d1'
    };

    // Game state
    let obstacles = [];
    let platforms = [];
    let particles = []; // IMPROVEMENT: part√≠culas leves
    let frame = 0;
    let speed = 4; // base
    let score = 0;
    let record = parseInt(localStorage.getItem('geometryCrashRecord')||'0',10) || 0;
    recordEl.textContent = record;
    let running = true; // controla loop para evitar init duplo

    // Input
    function attemptJump(){
      if(player.grounded){
        player.dy = player.jumpForce;
        player.grounded = false;
        sndJump.currentTime = 0;
        sndJump.play().catch(()=>{});
        // pequenas part√≠culas no pulo
        spawnParticles(player.x+player.w/2, player.y+player.h, '#00d0ff', 6, 2);
      }
    }
    document.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        e.preventDefault();
        attemptJump();
      }
    });
    jumpBtn.addEventListener('click', attemptJump);
    canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); attemptJump(); }, {passive:false});

    // Spawn obstacles and platforms
    function spawn(){
      const r = Math.random();
      if (r < 0.5) {
        // bloco neon com borda
        obstacles.push({
          type:'block',
          x: W + 20,
          y: groundY - 24 - (Math.random() < 0.25 ? 20 : 0),
          w: 24 + Math.floor(Math.random()*18),
          h: 24 + Math.floor(Math.random()*26),
          color: '#22ffd6'
        });
      } else if (r < 0.8) {
        // spike (simples ou duplo)
        const isDouble = Math.random() < 0.33;
        if(!isDouble){
          obstacles.push({
            type:'spike',
            x: W + 10,
            y: groundY - 20,
            w: 22, h: 20
          });
        } else {
          obstacles.push({ type:'spike', x: W + 10, y: groundY - 20, w: 16, h: 20 });
          obstacles.push({ type:'spike', x: W + 10 + 22, y: groundY - 20, w: 16, h: 20 });
        }
      } else {
        // plataforma elevada com gradiente
        const py = groundY - 80 - Math.floor(Math.random()*80);
        platforms.push({
          x: W + 10,
          y: py,
          w: 80 + Math.floor(Math.random()*70),
          h: 12
        });
      }
    }

    // Collision AABB helper
    function collide(a,b){
      return a.x < b.x + b.w &&
             a.x + a.w > b.x &&
             a.y < b.y + b.h &&
             a.y + a.h > b.y;
    }

    // Part√≠culas simples (IMPROVEMENT)
    function spawnParticles(x, y, color, count=6, speed=2){
      for(let i=0;i<count;i++){
        particles.push({
          x, y,
          vx: (Math.random()*2-1)*speed,
          vy: -Math.random()*speed-0.5,
          life: 16 + Math.random()*12,
          color
        });
      }
    }
    function updateParticles(){
      for(let i=particles.length-1;i>=0;i--){
        const p=particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.12;
        p.life--;
        if(p.life<=0) particles.splice(i,1);
      }
    }
    function drawParticles(){
      for(const p of particles){
        const alpha = Math.max(0, p.life/28);
        ctx.fillStyle = `rgba(0,208,255,${alpha})`;
        ctx.fillRect(p.x-1, p.y-1, 2, 2);
      }
    }

    // Background helpers (IMPROVEMENT: gradiente + estrelas leves)
    const stars = Array.from({length:32}, ()=>({
      x: Math.random()*W, y: Math.random()*H*0.8, r: Math.random()*1.2+0.3, tw: Math.random()*Math.PI*2
    }));
    function drawBackground(){
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0,'#021017');
      g.addColorStop(0.5,'#051a24');
      g.addColorStop(1,'#061f2c');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      // stars parallax
      ctx.save();
      for(let i=0;i<stars.length;i++){
        const s = stars[i];
        const y = s.y + Math.sin((frame*0.01+i)*0.6)*0.2;
        const a = 0.5 + 0.5*Math.sin(s.tw + frame*0.03);
        ctx.fillStyle = `rgba(160,255,255,${0.15 + 0.25*a})`;
        ctx.beginPath();
        ctx.arc(s.x, y, s.r, 0, Math.PI*2);
        ctx.fill();
        s.x -= 0.2; // lento
        if(s.x < -2){ s.x = W+2; s.y = Math.random()*H*0.8; }
      }
      ctx.restore();

      // ground
      ctx.save();
      // faixa do ch√£o
      ctx.fillStyle = '#0b1114';
      ctx.fillRect(0, groundY, W, H-groundY);
      // striping sutil
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = '#00f0d1';
      for(let x=0; x<W; x+=24) ctx.fillRect(x, groundY, 12, 6);
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Neon stroke helper (IMPROVEMENT)
    function neonRect(x,y,w,h, base='#18ffd8'){
      // fill
      ctx.fillStyle = 'rgba(24,255,216,0.12)';
      ctx.fillRect(x,y,w,h);
      // edge glow via gradient stroke
      const grd = ctx.createLinearGradient(x,y,x+w,y+h);
      grd.addColorStop(0, '#00f0d1');
      grd.addColorStop(1, '#00d0ff');
      ctx.strokeStyle = grd;
      ctx.lineWidth = 2;
      ctx.strokeRect(x+0.5,y+0.5,w-1,h-1);
    }

    function spikePath(o){
      ctx.beginPath();
      ctx.moveTo(o.x, o.y + o.h);
      ctx.lineTo(o.x + o.w/2, o.y);
      ctx.lineTo(o.x + o.w, o.y + o.h);
      ctx.closePath();
    }

    // Desenho principal
    function update(){
      if(!running) return;
      frame++;
      // background
      ctx.clearRect(0,0,W,H);
      drawBackground();

      // player physics
      player.dy += player.gravity;
      player.y += player.dy;
      if(player.y + player.h >= groundY){
        player.y = groundY - player.h;
        player.dy = 0;
        player.grounded = true;
      } else {
        player.grounded = false;
      }

      // plataformas
      for(let i=platforms.length-1;i>=0;i--){
        const p = platforms[i];
        p.x -= speed;

        // plataforma com gradiente
        const grad = ctx.createLinearGradient(p.x,p.y,p.x+p.w,p.y);
        grad.addColorStop(0,'#2a2a8f');
        grad.addColorStop(1,'#00d0ff');
        ctx.fillStyle = grad;
        ctx.fillRect(p.x,p.y,p.w,p.h);

        // top-only collision
        if (
          player.dy >= 0 &&
          player.x + player.w > p.x + 6 &&
          player.x < p.x + p.w - 6 &&
          player.y + player.h <= p.y + 4 &&
          player.y + player.h + player.dy >= p.y
        ) {
          player.y = p.y - player.h;
          player.dy = 0;
          player.grounded = true;
        }
        if(p.x + p.w < -50) platforms.splice(i,1);
      }

      // obst√°culos
      for(let i=obstacles.length-1;i>=0;i--){
        const o = obstacles[i];
        o.x -= speed;

        if(o.type === 'block'){
          // bloco com leve rota√ß√£o e neon ‚Äúedge‚Äù
          ctx.save();
          const cx = o.x + o.w/2, cy = o.y + o.h/2;
          const angle = Math.sin((frame + i*7)/24) * 0.09;
          ctx.translate(cx,cy);
          ctx.rotate(angle);
          neonRect(-o.w/2,-o.h/2,o.w,o.h);
          ctx.restore();
        } else if(o.type === 'spike'){
          // spike com brilho quente
          ctx.save();
          spikePath(o);
          const grad = ctx.createLinearGradient(o.x,o.y, o.x, o.y+o.h);
          grad.addColorStop(0, '#ffc36b');
          grad.addColorStop(1, '#ff8a3a');
          ctx.fillStyle = grad;
          ctx.fill();
          ctx.restore();
        }

        // colis√£o
        if (
          player.x < o.x + o.w &&
          player.x + player.w > o.x &&
          player.y < o.y + o.h &&
          player.y + player.h > o.y
        ) {
          sndDie.currentTime = 0;
          sndDie.play().catch(()=>{});
          endGame();
          return;
        }

        if(o.x + o.w < -40){
          obstacles.splice(i,1);
          score++;
          scoreElUpdate();
          sndPoint.currentTime = 0;
          sndPoint.play().catch(()=>{});
          // part√≠culas de ponto
          spawnParticles(player.x+player.w/2, player.y+player.h/2, '#00f0d1', 5, 1.6);
        }
      }

      // player (tri√¢ngulo) com ‚Äúouter glow‚Äù moderado
      const rot = Math.max(-0.6, Math.min(0.6, player.dy * 0.03));
      ctx.save();
      ctx.translate(player.x + player.w/2, player.y + player.h/2);
      ctx.rotate(rot);
      // glow radial leve ao redor do player (sem shadowBlur pesado)
      const rg = ctx.createRadialGradient(0,0,6, 0,0,16);
      rg.addColorStop(0,'rgba(0,240,209,0.18)');
      rg.addColorStop(1,'rgba(0,240,209,0)');
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(0,0,16,0,Math.PI*2); ctx.fill();

      // tri√¢ngulo
      const triGrad = ctx.createLinearGradient(-player.w/2,0,player.w/2,0);
      triGrad.addColorStop(0, '#00f0d1');
      triGrad.addColorStop(1, '#00d0ff');
      ctx.fillStyle = triGrad;
      ctx.beginPath();
      ctx.moveTo(-player.w/2, player.h/2);
      ctx.lineTo(0, -player.h/2);
      ctx.lineTo(player.w/2, player.h/2);
      ctx.closePath();
      ctx.fill();

      // contorno
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();

      // part√≠culas
      updateParticles();
      drawParticles();

      // speed ramp
      if(score > 30) speed = 10;
      else if(score > 15) speed = 5.5;
      else speed = 4 + Math.floor(score/10)*0.5;

      // spawn logic
      if(frame % Math.max(40, 90 - Math.floor(score/2)) === 0){
        spawn();
      }

      // UI overlay pequena
      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.fillRect(8,8,220,36);
      ctx.fillStyle = '#00f0d1';
      ctx.font = '16px Inter, Arial';
      ctx.fillText('Pontua√ß√£o: '+score, 18, 32);

      requestAnimationFrame(update);
    }

    function scoreElUpdate(){
      scoreEl.textContent = String(score);
      if(score > record){
        record = score;
        localStorage.setItem('geometryCrashRecord', String(record));
        recordEl.textContent = String(record);
      }
    }

    function endGame(){
      running = false;
      setTimeout(()=>{
        const again = confirm('üí• Fim de jogo! Seu recorde √©: '+record+'\n\nDeseja jogar novamente?');
        if(again){
          resetGame();
          init();
        }
      }, 80);
    }

    function resetGame(){
      obstacles = []; platforms = []; particles = []; frame = 0; score = 0;
      player.y = groundY - player.h; player.dy = 0; player.grounded = true;
      speed = 4;
      scoreElUpdate();
    }

    function init(){
      running = true;
      score = 0;
      scoreElUpdate();
      platforms = [];
      obstacles = [];
      requestAnimationFrame(update);
    }

    // Acessibilidade: foco no canvas ao carregar (√∫til em iframe)
    canvas.addEventListener('pointerdown', ()=>canvas.focus());
    canvas.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ e.preventDefault(); attemptJump(); } });

    init();

  })();
  </script>
</body>
</html>
