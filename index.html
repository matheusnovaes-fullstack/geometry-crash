<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Geometry Crash</title>
  <link rel="icon" href="favicon.ico" />
  <style>
    :root{
      --bg1:#081421;
      --accent:#00f0d1;
      --accent-2:#00d0ff;
      --gold:#ffd166;
      --muted:#99a0a6;
      --warn:#29ffa5;
    }
    html,body{
      height:100%; margin:0;
      font-family:Inter,"Segoe UI",Roboto,Arial,sans-serif;
      background:linear-gradient(180deg,var(--bg1),#071018 80%);
      color:#e6f7f2;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .container{ max-width:720px; margin:18px auto; padding:18px; box-sizing:border-box; text-align:center; }
    h1{ margin:0 0 12px; font-size:20px; letter-spacing:.5px; }
    .game-card{
      background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(0,0,0,.06));
      border-radius:12px; padding:14px;
      box-shadow:0 6px 30px rgba(0,0,0,.6), inset 0 1px 0 rgba(255,255,255,.02);
      border:1px solid rgba(255,255,255,.03);
      display:flex; flex-direction:column; align-items:center;
    }
    /* Canvas com raz√£o 16:9 est√°vel e altura m√≠nima para mobile */
    canvas{
      background:linear-gradient(180deg,#031219 0%, #071423 100%);
      width:100%;
      max-width:640px;
      aspect-ratio: 16 / 9;   /* for√ßa 16:9 */
      height:auto;
      min-height: 320px;      /* garante √°rea vis√≠vel em iOS */
      border-radius:12px;
      border:2px solid rgba(0,240,209,.10);
      box-shadow:0 12px 48px rgba(0,0,0,.7), 0 0 24px rgba(0,240,209,.10), inset 0 0 0 1px rgba(255,255,255,.02);
      outline:none;
      touch-action:none;
    }
    #hud{ margin-top:10px; display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap; }
    .scoreBox{
      background:rgba(255,255,255,.06);
      backdrop-filter:blur(6px);
      padding:8px 12px; border-radius:10px; font-weight:700;
      color:var(--accent); border:1px solid rgba(255,255,255,.08);
    }
    .record{ color:var(--gold); }
    #jumpBtn{
      padding:10px 16px; border-radius:12px;
      background:linear-gradient(180deg,var(--accent),var(--accent-2));
      border:none; color:#012; font-weight:800; cursor:pointer;
      box-shadow:0 8px 18px rgba(0,208,255,.18);
      transition:transform .06s ease, filter .12s ease;
    }
    #jumpBtn:hover{ filter:brightness(1.05); }
    #jumpBtn:active{ transform:translateY(1px) scale(.99); }
    .controls{ margin-top:8px; font-size:13px; color:var(--muted); }
    @media(max-width:520px){
      /* mant√©m a propor√ß√£o; min-height j√° segura a altura */
      #jumpBtn{ padding:12px 18px; font-size:16px; }
    }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Jogo Geometry Crash">
    <h1>Geometry Crash ‚Äî Jogue enquanto espera</h1>
    <div class="game-card">
      <canvas id="game" width="640" height="360" role="img" aria-label="Jogo Geometry Crash" tabindex="0"></canvas>

      <div id="hud">
        <div class="scoreBox">Pontua√ß√£o: <span id="score">0</span></div>
        <div class="scoreBox record">Recorde: <span id="record">0</span></div>
        <button id="jumpBtn" aria-label="Pular">PULAR</button>
      </div>

      <div class="controls">Toque / Clique ou Espa√ßo para pular ‚Äî Recorde salvo localmente</div>
    </div>
  </div>

  <script>
  (function(){
    // Canvas & DPI robusto
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha:true, desynchronized:true });

    function getCssSize() {
      // Usa clientWidth e a altura derivada do aspect-ratio; como fallback, usa boundingClientRect
      const w = Math.max(1, Math.round(canvas.clientWidth || canvas.getBoundingClientRect().width || 640));
      // 16:9 a partir da largura, respeitando min-height via CSS automaticamente no layout
      const computedH = Math.round(w * 9 / 16);
      const h = Math.max(computedH, Math.round(parseFloat(getComputedStyle(canvas).minHeight) || 320));
      return { w, h };
    }

    function setupDPI(){
      let dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1)); // limita DPR alto em mobile para estabilidade
      const css = getCssSize();
      canvas.width  = Math.round(css.w * dpr);
      canvas.height = Math.round(css.h * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return { W: css.w, H: css.h };
    }

    let { W, H } = setupDPI();
    let groundY = H - 40;

    // Recalcula de forma est√°vel em mobile
    let resizeRAF = null;
    function onResizeStable(){
      if (resizeRAF) cancelAnimationFrame(resizeRAF);
      resizeRAF = requestAnimationFrame(()=>{
        const prev = { score, record, speed };
        ({ W, H } = setupDPI());
        groundY = H - 40;

        // Reposiciona player dentro da tela
        player.y = Math.min(player.y, groundY - player.h);
        if (player.y + player.h > H) player.y = Math.max(0, groundY - player.h);

        // Clampa entidades existentes para n√£o ‚Äúsumirem‚Äù
        for (const p of platforms){ p.y = Math.max(0, Math.min(p.y, groundY - 12)); }
        for (const o of obstacles){ o.y = Math.max(0, Math.min(o.y, groundY - o.h)); }
        for (const h of holes){ h.y = groundY; h.h = H - groundY; }

        score = prev.score; record = prev.record; speed = prev.speed;

        seedStars(); // re-semeia estrelas com novo tamanho
      });
    }
    window.addEventListener('resize', onResizeStable);
    // iOS ‚Äúzoom‚Äù ao mostrar barra de URL
    window.addEventListener('orientationchange', onResizeStable);

    // Pontos
    const scoreEl = document.getElementById('score');
    const recordEl = document.getElementById('record');

    // √Åudio somente morte/explos√£o (pulo/ponto removidos)
    let audioCtx = null, useWebAudio=false;
    let sfx = { die:null, boom:null };
    const SFX_URLS = {
      die:'https://actions.google.com/sounds/v1/cartoon/concussive_hit_guitar_boing.ogg',
      boom:'https://actions.google.com/sounds/v1/impacts/crash.ogg'
    };
    const htmlSfx = {
      die:  new Audio(SFX_URLS.die),
      boom: new Audio(SFX_URLS.boom)
    };
    async function initAudioContextOnce(){
      if(audioCtx) return;
      try{
        audioCtx = new (window.AudioContext||window.webkitAudioContext)({ latencyHint:'interactive' });
        if(audioCtx.state==='suspended') await audioCtx.resume();
        for(const [key,url] of Object.entries(SFX_URLS)){
          const res = await fetch(url); const arr = await res.arrayBuffer();
          sfx[key] = await audioCtx.decodeAudioData(arr);
        }
        useWebAudio = true;
      }catch(e){ useWebAudio = false; }
    }
    function playSfx(name, gain=1.0, rate=1.0){
      if(useWebAudio && sfx[name] && audioCtx){
        const src = audioCtx.createBufferSource(); src.buffer=sfx[name]; src.playbackRate.value=rate;
        const g = audioCtx.createGain(); g.gain.value=gain;
        src.connect(g).connect(audioCtx.destination); src.start(0);
      } else {
        const a = htmlSfx[name]; if(!a) return; a.currentTime=0; a.play().catch(()=>{});
      }
    }
    const primeAudio = async ()=>{ await initAudioContextOnce(); };

    // Input
    const jumpBtn = document.getElementById('jumpBtn');
    let jumpQueued=false;
    function queueJump(){ jumpQueued=true; }
    jumpBtn.addEventListener('click', ()=>{ queueJump(); primeAudio(); });
    canvas.addEventListener('touchstart', ()=>{ queueJump(); primeAudio(); }, { passive:true });
    canvas.addEventListener('pointerdown', ()=>{ canvas.focus(); primeAudio(); }, { passive:true });
    document.addEventListener('keydown', e=>{
      if(e.code==='Space'){ e.preventDefault(); queueJump(); primeAudio(); }
    }, { passive:false });

    // Player
    const player = { x:80, y:groundY-24, w:24, h:24, dy:0, gravity:0.9, jumpForce:-12, grounded:true };

    // Estado
    const obstacles=[], platforms=[], holes=[], particles=[], flashes=[];
    let frame=0, speed=4, score=0, record=parseInt(localStorage.getItem('geometryCrashRecord')||'0',10)||0;
    let running=true;
    recordEl.textContent = record;

    // Spawn timer ms
    let lastSpawnTime = 0;
    let spawnIntervalMs = 1200;
    function scheduleSpawn(now){
      const target = Math.max(450, 1200 - score*20);
      spawnIntervalMs = target;
      if (now - lastSpawnTime >= spawnIntervalMs) {
        spawn();
        lastSpawnTime = now;
      }
    }

    // AABB temp
    const AABB_a={x:0,y:0,w:0,h:0}, AABB_b={x:0,y:0,w:0,h:0};

    function attemptJump(){
      if(player.grounded){
        player.dy = player.jumpForce; player.grounded=false;
        // part√≠culas no pulo
        spawnParticles(player.x+player.w/2, player.y+player.h, '#00d0ff', 8, 2.2);
      }
    }

    // Gera√ß√£o
    let lastHoleEndX = -9999;
    function spawn(){
      const r = Math.random();
      if(r < 0.48){
        obstacles.push({ type:'block', x:W+20, y:Math.max(0, groundY-24-(Math.random()<0.25?20:0)), w:24+Math.floor(Math.random()*18), h:24+Math.floor(Math.random()*26) });
      } else if (r < 0.78){
        const dbl = Math.random()<0.33;
        if(!dbl) obstacles.push({ type:'spike', x:W+10, y:Math.max(0, groundY-20), w:22, h:20 });
        else { obstacles.push({type:'spike',x:W+10,y:Math.max(0, groundY-20),w:16,h:20}); obstacles.push({type:'spike',x:W+32,y:Math.max(0, groundY-20),w:16,h:20}); }
      } else if (r < 0.9){
        const py = Math.max(0, groundY - 80 - Math.floor(Math.random()*80));
        platforms.push({ x:W+10, y:py, w:80+Math.floor(Math.random()*70), h:12 });
      } else {
        const minW=36, maxW=72;
        const wHole = minW + Math.floor(Math.random()*(maxW-minW+1));
        const minGap = 140;
        const startX = Math.max(W+10, lastHoleEndX + minGap);
        holes.push({ x:startX, y:groundY, w:wHole, h:H-groundY });
        lastHoleEndX = startX + wHole;
      }
    }

    // Part√≠culas
    function spawnParticles(x,y,color,count=12,speed=3,spread=Math.PI*2){
      for(let i=0;i<count;i++){
        const ang = Math.random()*spread, spd = speed*(0.5+Math.random());
        particles.push({ x, y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd, life:24+Math.random()*18, color });
      }
    }
    function spawnExplosion(x,y){
      flashes.push({ life:12, x, y });
      spawnParticles(x,y,'#00f0d1',16,3.2);
      spawnParticles(x,y,'#00d0ff',12,2.8);
      spawnParticles(x,y,'#ffffff',10,2.4);
      playSfx('boom', 0.9, 1.0);
    }
    function updateParticles(){
      for(let i=particles.length-1;i>=0;i--){
        const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.15; p.life--;
        if(p.life<=0) particles.splice(i,1);
      }
      for(let i=flashes.length-1;i>=0;i--){
        const f=flashes[i]; f.life--; if(f.life<=0) flashes.splice(i,1);
      }
    }
    function drawParticles(){
      for(const p of particles){
        const a = Math.max(0, p.life/30);
        ctx.fillStyle = `rgba(0,240,255,${a})`;
        ctx.fillRect(p.x-1,p.y-1,2,2);
      }
      for(const f of flashes){
        const alpha = f.life/12, rad = 60*(1-alpha)+20;
        const g = ctx.createRadialGradient(f.x,f.y,0, f.x,f.y,rad);
        g.addColorStop(0,`rgba(255,255,255,${0.35*alpha})`);
        g.addColorStop(1,'rgba(255,255,255,0)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(f.x,f.y,rad,0,Math.PI*2); ctx.fill();
      }
    }

    // C√©u (gradiente, aurora e estrelas em camadas)
    const starLayers = [
      { n: 18, speed: 0.08, twinkle: 0.015, col: 'rgba(180,255,255,', arr: [] },
      { n: 22, speed: 0.18, twinkle: 0.025, col: 'rgba(200,255,255,', arr: [] },
      { n: 26, speed: 0.30, twinkle: 0.035, col: 'rgba(255,255,220,', arr: [] }
    ];
    function seedStars(){
      for(const L of starLayers){
        L.arr = Array.from({length: L.n}, ()=>({
          x: Math.random()*W,
          y: Math.random()*H*0.75,
          r: Math.random()*1.3 + 0.35,
          p: Math.random()*Math.PI*2
        }));
      }
    }
    seedStars();

    function drawBackground(){
      const sky = ctx.createLinearGradient(0,0,0,H);
      sky.addColorStop(0.0,'#02101a');
      sky.addColorStop(0.55,'#051b26');
      sky.addColorStop(1.0,'#072233');
      ctx.fillStyle = sky;
      ctx.fillRect(0,0,W,H);

      const horizon = ctx.createRadialGradient(W*0.5, H*0.92, 6, W*0.5, H*0.92, Math.max(W,H));
      horizon.addColorStop(0,'rgba(0,240,209,0.10)');
      horizon.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle = horizon;
      ctx.fillRect(0,0,W,H);

      const t = frame * 0.005;
      const auroraY = H*0.28 + Math.sin(frame*0.01)*6;

      const a1 = ctx.createLinearGradient(0, auroraY-40, 0, auroraY+60);
      a1.addColorStop(0,'rgba(80,250,200,0)');
      a1.addColorStop(0.45,'rgba(80,250,200,0.08)');
      a1.addColorStop(0.85,'rgba(0,180,255,0.04)');
      a1.addColorStop(1,'rgba(0,0,0,0)');
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.translate(Math.sin(t)*30, 0);
      ctx.fillStyle = a1;
      ctx.fillRect(-40, auroraY-60, W+80, 140);
      ctx.restore();

      const auroraY2 = auroraY + 26;
      const a2 = ctx.createLinearGradient(0, auroraY2-50, 0, auroraY2+70);
      a2.addColorStop(0,'rgba(120,255,220,0)');
      a2.addColorStop(0.5,'rgba(120,255,220,0.06)');
      a2.addColorStop(1,'rgba(0,0,0,0)');
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.translate(Math.cos(t*0.8)*20, 0);
      ctx.fillStyle = a2;
      ctx.fillRect(-40, auroraY2-70, W+80, 160);
      ctx.restore();

      for(const L of starLayers){
        for(let i=0;i<L.arr.length;i++){
          const s = L.arr[i];
          s.x -= L.speed;
          if(s.x < -2){ s.x = W+2; s.y = Math.random()*H*0.75; }
          const tw = 0.35 + 0.65*Math.abs(Math.sin(s.p + frame*L.twinkle));
          ctx.fillStyle = `${L.col}${0.12 + 0.28*tw})`;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.r * (0.85 + 0.3*tw), 0, Math.PI*2);
          ctx.fill();
        }
      }

      ctx.fillStyle='#0b1114';
      ctx.fillRect(0, groundY, W, H-groundY);
      ctx.globalAlpha=.08; ctx.fillStyle='#00f0d1';
      for(let x=0;x<W;x+=24) ctx.fillRect(x, groundY, 12, 6);
      ctx.globalAlpha=1;
    }

    // Buracos destacados
    function drawHoles(){
      const pitJitter = Math.sin(frame*0.03)*0.6;
      for (const h of holes) {
        const top = groundY;
        const warnX = h.x - 16;
        const pulse = 0.6 + 0.4*Math.sin(frame*0.2);
        ctx.fillStyle = `rgba(41,255,165,${0.35*pulse})`;
        ctx.fillRect(warnX, top-10, 2, 10);

        const rg = ctx.createRadialGradient(
          h.x + h.w/2, top + 18 + pitJitter, 6,
          h.x + h.w/2, top + 18 + pitJitter, Math.max(h.w, 100)
        );
        rg.addColorStop(0,  'rgba(0,240,209,0.10)');
        rg.addColorStop(0.35,'rgba(0,160,200,0.22)');
        rg.addColorStop(0.7, 'rgba(0,60,100,0.55)');
        rg.addColorStop(1,  'rgba(0,24,40,0.90)');
        ctx.fillStyle = rg;
        ctx.fillRect(h.x, top, h.w, H - top);

        const rim = ctx.createLinearGradient(h.x, top - 1, h.x, top + 7);
        rim.addColorStop(0, '#00f0d1'); rim.addColorStop(1, 'rgba(0,240,209,0)');
        ctx.fillStyle = rim; ctx.fillRect(h.x - 1, top - 2, h.w + 2, 9);

        ctx.strokeStyle = 'rgba(255,255,255,0.26)';
        ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(h.x, top + 0.5); ctx.lineTo(h.x + h.w, top + 0.5); ctx.stroke();
      }
    }

    // Loop
    function update(){
      if(!running) return;

      if(jumpQueued){ jumpQueued=false; attemptJump(); }

      frame++;
      ctx.clearRect(0,0,W,H);
      drawBackground();

      // mover entidades
      for(let i=platforms.length-1;i>=0;i--){
        const p=platforms[i]; p.x-=speed;
        if(p.x+p.w<-50) platforms.splice(i,1);
      }
      for(let i=obstacles.length-1;i>=0;i--){
        const o=obstacles[i]; o.x-=speed;
        if(o.x+o.w<-40){ obstacles.splice(i,1); score++; scoreElUpdate(); }
      }
      for(let i=holes.length-1;i>=0;i--){
        const h=holes[i]; h.x-=speed; h.y=groundY; h.h=H-groundY; // mant√©m aderente ao ch√£o
        if(h.x+h.w<-60) holes.splice(i,1);
      }

      drawHoles();

      // f√≠sica
      player.dy += player.gravity; player.y += player.dy;

      // Guarda para nunca sair do topo
      if(player.y < -10){ player.y = -10; player.dy = Math.max(0, player.dy); }

      // suporte de ch√£o vs buraco
      let overHole=false;
      for(const h of holes){ if(player.x+player.w>h.x && player.x<h.x+h.w){ overHole=true; break; } }
      if(!overHole && player.y + player.h >= groundY){
        player.y = groundY - player.h; player.dy = 0; player.grounded = true;
      } else if (overHole && player.y + player.h >= groundY){
        player.grounded = false;
      }

      // plataformas com colis√£o total
      for(const p of platforms){
        const grad=ctx.createLinearGradient(p.x,p.y,p.x+p.w,p.y); grad.addColorStop(0,'#2a2a8f'); grad.addColorStop(1,'#00d0ff');
        ctx.fillStyle=grad; ctx.fillRect(p.x,p.y,p.w,p.h);
        AABB_a.x=player.x; AABB_a.y=player.y; AABB_a.w=player.w; AABB_a.h=player.h;
        AABB_b.x=p.x; AABB_b.y=p.y; AABB_b.w=p.w; AABB_b.h=p.h;
        const ox = Math.min(AABB_a.x+AABB_a.w, AABB_b.x+AABB_b.w) - Math.max(AABB_a.x, AABB_b.x);
        const oy = Math.min(AABB_a.y+AABB_a.h, AABB_b.y+AABB_b.h) - Math.max(AABB_a.y, AABB_b.y);
        if(ox>0.5 && oy>0.5){
          if(ox<oy){
            if(AABB_a.x+AABB_a.w/2 < AABB_b.x+AABB_b.w/2) player.x -= ox; else player.x += ox;
          }else{
            if(AABB_a.y+AABB_a.h/2 < AABB_b.y+AABB_b.h/2){ player.y -= oy; player.dy=0; player.grounded=true; }
            else { player.y += oy; if(player.dy<0) player.dy=0; }
          }
        }
      }

      // morte por queda (fora da tela inferior)
      if(player.y > H + 40){ spawnExplosion(player.x+player.w/2, H-10); playSfx('die', 0.9, 1.0); gameOver(); return; }

      // obst√°culos + colis√£o
      for(const o of obstacles){
        if(o.type==='block'){
          ctx.save(); const cx=o.x+o.w/2, cy=o.y+o.h/2; const angle=Math.sin((frame+7)/24)*0.09;
          ctx.translate(cx,cy); ctx.rotate(angle); neonRect(-o.w/2,-o.h/2,o.w,o.h); ctx.restore();
        } else {
          ctx.save(); ctx.beginPath();
          ctx.moveTo(o.x,o.y+o.h); ctx.lineTo(o.x+o.w/2,o.y); ctx.lineTo(o.x+o.w,o.y+o.h); ctx.closePath();
          const g=ctx.createLinearGradient(o.x,o.y,o.x,o.y+o.h); g.addColorStop(0,'#ffc36b'); g.addColorStop(1,'#ff8a3a');
          ctx.fillStyle=g; ctx.fill(); ctx.restore();
        }
        if (player.x < o.x+o.w && player.x+player.w > o.x && player.y < o.y+o.h && player.y+player.h > o.y){
          spawnExplosion(player.x+player.w/2, player.y+player.h/2); playSfx('die', 0.9, 1.0); gameOver(); return;
        }
      }

      // player (clamp horizontal para n√£o ‚Äúsumir‚Äù em resize extremo)
      player.x = Math.max(0, Math.min(player.x, W - player.w - 1));

      const rot = Math.max(-0.6, Math.min(0.6, player.dy * 0.03));
      ctx.save();
      ctx.translate(player.x + player.w/2, player.y + player.h/2);
      ctx.rotate(rot);
      const rg=ctx.createRadialGradient(0,0,6,0,0,16); rg.addColorStop(0,'rgba(0,240,209,.18)'); rg.addColorStop(1,'rgba(0,240,209,0)');
      ctx.fillStyle=rg; ctx.beginPath(); ctx.arc(0,0,16,0,Math.PI*2); ctx.fill();
      const tri=ctx.createLinearGradient(-player.w/2,0,player.w/2,0); tri.addColorStop(0,'#00f0d1'); tri.addColorStop(1,'#00d0ff');
      ctx.fillStyle=tri; ctx.beginPath(); ctx.moveTo(-player.w/2,player.h/2); ctx.lineTo(0,-player.h/2); ctx.lineTo(player.w/2,player.h/2); ctx.closePath(); ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,.25)'; ctx.lineWidth=1; ctx.stroke();
      ctx.restore();

      updateParticles(); drawParticles();

      scheduleSpawn(performance.now());

      if(score>30) speed=10; else if(score>15) speed=5.5; else speed=4+Math.floor(score/10)*0.5;

      ctx.fillStyle='rgba(0,0,0,.12)'; ctx.fillRect(8,8,220,36);
      ctx.fillStyle='#00f0d1'; ctx.font='16px Inter, Arial'; ctx.fillText('Pontua√ß√£o: '+score,18,32);

      requestAnimationFrame(update);
    }

    function scoreElUpdate(){
      scoreEl.textContent=String(score);
      if(score>record){
        record=score; localStorage.setItem('geometryCrashRecord', String(record));
        recordEl.textContent=String(record);
      }
    }

    function gameOver(){
      running=false;
      setTimeout(()=>{ const again=confirm('üí• Fim de jogo! Seu recorde √©: '+record+'\n\nDeseja jogar novamente?'); if(again){ resetGame(); init(); } }, 160);
    }

    function resetGame(){
      obstacles.length=0; platforms.length=0; holes.length=0; particles.length=0; flashes.length=0;
      frame=0; score=0; speed=4;
      player.x=80; player.y=groundY-player.h; player.dy=0; player.grounded=true;
      scoreElUpdate();
      lastSpawnTime = performance.now() - spawnIntervalMs;
    }

    function init(){
      running=true; score=0; scoreElUpdate();
      spawn(); // primeiro spawn garantido
      lastSpawnTime = performance.now();
      requestAnimationFrame(update);
    }

    init();
  })();
  </script>
</body>
</html>
